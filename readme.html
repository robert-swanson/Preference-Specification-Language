**Project - Domain-Specific Language**

<!--

General
========

For each of your team's implementations, explain the following (where appropriate and applicable):

- details on calling conventions, input and output data formats, limitations, bugs, and special features.
- negative aspects of your program (limitations, known bugs)
- positive aspects (extensions, special features)
- describe your choice of modularization (abstractions), data structures, and algorithms
- explain anything you did that is likely to be different from what other students may have done
- justify any design decisions for which the rationale isn't immediately clear

Feel free to modify the structure of this `readme.html` file to fit the current assignment and to fit how you wish to present your findings.


-->


Authors
=============

<!-- Note: wrapping table in div.noheader will hide the table's header -->
<!-- Note: wrapping table in div.firstcol will style the first column different from other columns -->
<div class="noheader firstcol">
  1              | 2
------------------|-------------
names             | Rob Swanson & Liz Yeiter
computer + OS     | macbook
time to complete  | 9 hrs
partner           | see names
additional help   | see Reflection section
</div>



Project Selection
=================
Define the Domain
------------------
College course recomendation based off of degree requirements and student preferences.
The end goal is to make a language that can specify user preferences for Envisage.

<!--(What is the purpose of the language?) -->
Define the Problem
------------------
How does the user express the requirements of their degree and their personal preferences to the planning engine?
There is a lot to think about when creating a plan, and all the moving parts can be overwhelming, which is what this language will strive to help.


<!-- Create example "solutions". What is the expected output for some examples of valid input? -->
Expected Solutions
------------------
The input would be a `.psl` file that specifies user preferences and degree requirements in a human readable format.
(We renamed the type of file from `.cps` to `.psl`, Preference Specification Language, on 3.13.21)
For example, the following file describes a few requirements and then specifies a few user preferences
~~~~
definitions {
priority strongly 10.
priority moderately 5.
priority slightly 1.
}

computerScienceBSRequirements {
require "COS 102".
require "COS 103".
require "COS 120".
require "COS 121".

require 1 of "COS 311", "COS 321".
require 2 of "COS 381", "COS 421", "COS 436".

require 128 hours.
require 42 upper division credits.

require taking "COS 120" before "COS 121".
}

studentPreferences {
prefer strongly "COS 121".
prefer moderately later classes.

if taking "COS 436" then {
prefer slightly "COS 381".
prefer slightly not taking "COS 421".
} otherwise {
prefer slightly not taking "COS 421".
}

when taking "COS 381" {
prefer moderately less credits.
}

when (taking "COS 381" and taking "COS 333") {
prefer moderately less credits.
}

when ((taking "COS 381" or taking "MAT 215") and taking "COS 121") {
prefer moderately less credits.
}

when (taking "COS 381" or (taking "MAT 215" and taking "COS 121")) {
prefer moderately less credits.
}

require "COS 121".
require not "COS 121".
prefer moderately "COS 121".
}
~~~~
[Example `good-integrated.psl`]

The output would be a python file which includes a python function for each requirement, which takes in the context of a plan and returns some value corresponding to that requirement's satisfaction.
Other possible outputs could be a prolog fact file or a json document.
This output file would probably not be of much use to the user without other tools to create or pass in plans.

~~~~ Python
import helpers

STRONGLY = 10
MODERATLY = 5
SLIGHTLY = 1

def isValidPlan(plan):
    return (
        courseNameInPlan(plan, "COS 102") and
        courseNameInPlan(plan, "COS 103") and
        courseNameInPlan(plan, "COS 120") and
        courseNameInPlan(plan, "COS 121") and

        nCourseNamesInPlan(plan, 1, ["COS 311", "COS 321"]) and
        nCourseNamesInPlan(plan, 2, ["COS 381", "COS 421", "COS 436"]) and

        credits() >= 128 and
        creditsOver(plan, 300) >= 42 and

        leftBeforeRight(plan, "COS 120", "COS 121")
    )

def planScore(plan):
    totalScore = 0
    maxScore = 0

    totalScore += STRONGLY * courseNameInPlan(plan, "COS 121")
    (totalScore, maxScore) = applyPreference(totalScore, maxScore, percentage, STRONGLY, courseNameInPlan(plan, "COS 121"))
    (totalScore, maxScore) = applyPreference(totalScore, maxScore, sigmoid, MODERATLY, averageMeetingTime(plan))

    if courseNameInPlan("COS 436"):
        (totalScore, maxScore) = applyPreference(totalScore, maxScore, percentage, SLIGHTLY, courseNameInPlan(plan, "COS 381"))
        (totalScore, maxScore) = applyPreference(totalScore, maxScore, percentage, SLIGHTLY, not courseNameInPlan(plan, "COS 421"))

    if courseNameInPlan("COS 381"):
        semesterContext = contextFromSemester(plan, plan.courses["COS 381"].semseter)
        (totalScore, maxScore) = applyPreference(totalScore, maxScore, reverseSigmoid, MODERATLY, credits(semesterContext))

    return totalScore/maxScore

~~~~
[Example `output.py`]
The compiler could create a python file like this, which could take in a python object (which could be provided and decoded from JSON) and can specify whether the plan is valid, and also the level to which the user preferences are met.
This file includes the `helpers.py` file which **is not generated** and provides basic functionality that supports preference and requiremnt validation.

~~~~
def courseNameInPlan(context, courseName):
    return context.courses.contains(courseName)

def nCourseNamesInPlan(context, n, fromCourseNames):
    count = 0
    for courseName in fromCourseNames:
        if courseNameInPlan(context, courseName):
            count += 1
            if count >= n:
                return true
    return false

def leftBeforeRight(context, leftCourseName, rightCourseName):
    if courseNameInPlan(leftCourseName) and courseNameInPlan(rightCourseName):
        return context.courses[leftCourseName].semseter < context.courses[rightCourseName].semseter

EARLIEST_MEETING_TIME = 800
LATEST_MEETING_TIME = 1500

def averageMeetingTime(context):
    timeSum = 0
    for meeting in context.meetings:
        timeSum += (meeting.time - EARLIEST_MEETING_TIME) / (LATEST_MEETING_TIME - EARLIEST_MEETING_TIME)
    return timeSum / len(context.meetings)

def credits(context):
    creditSum = 0
    for meeting in context.meetings:
        creditSum += meeting.credits
    return creditSum

def creditsOver(context, minCourseNumber):
    creditSum = 0
    for meeting in context.meetings:
        if meeting.courseNumber >= minCourseNumber:
            creditSum += meeting.credits
    return creditSum

def applyPreference(totalScore, maxScore, scaler, weight, score):
    return (totalScore+weight*scaler(preferenceSatisfaction), maxScore+weight)

def percentage(score):
    return min(max(score, 1), 0) * weight

def sigmoid(score):
    return weight/(1+10**(-score))
def reverseSigmoid(score):
    return weight/(1+10**(score))

def contextFromSemester(contextIn, semester):
    contextOut = { courses: [], meetings: [] }
    for meeting in contextIn.meeting:
        if meeting.semester == semester:
            contextOut.courses.append(meeting.course)
            contextOut.meetings.append(meeting)
~~~~
[helpers.py]

<!-- Define functionality. How is the output determined for a given input? -->
Define Functionality
------------------
A person making use of this system would start by creating a `.psl` input file that follows the language specification to define the requirements of their degrees (possibly by importing from other files).
They would then run the compiler which would produce a python file with two functions:
1. `isValidPlan(plan)` which returns a boolean
2. `planScore(plan)` which returns a double between 0 and 1, with 1 being the highest possible score, which can only be achived when all applied preferences are fully met (which is not possible for preferences which use a sigmoid function).
The user could populate a python object however they wish, but would likely do so by specifying a candidate plan in json, and then decoding it.
They could then pass this object to either function to evaluate it.

<!-- Talk with the professor, and get approval. -->
Approval
------------------
We talked to Dr. Denning about the difference between syntactic and semantic analysis and added a few types of symantic errors that we will check including

1. Verify counts for things such as `require 7 of "COS 381", "COS 421", "COS 436".`
2. Ensure that there are no prerequisite cycles.
~~~~
require "A" before "B".
require "B" before "A".
~~~~
3. Identify preference/requirement conflicts when two constrain the same thing differently, for example
~~~~
	require "COS 121".
	require not "COS 121".
	prefer moderately "COS 121".
~~~~


Splitting Up the Work
------------------
Rob made example input and output, and contributed to the readme.

Liz made the template README and filled out initial stuff and discussed semantic vs syntactic examples.

Grammar / Parser (we did these in one step)
================
Grammar
------------------
~~~~
grammar PSLGrammar;

start: block+ EOF;

block: NAME body;
body: '{' statement+ '}';
statement: require
| priority
| prefer
| if_
| when;

priority: PRIORITY NAME NUM PERIOD;
require: REQUIRE constraint PERIOD;
prefer: PREFER NAME constraint PERIOD;

if_: IF condition THEN body otherwiseIf* otherwise?;
otherwiseIf: OTHERWISE IF condition THEN body;
otherwise: OTHERWISE body;

when: WHEN condition body;

condition: TAKING STRING // course
| NOT condition // not
| OPENPAREND condition AND condition CLOSEPAREND
| OPENPAREND condition OR condition CLOSEPAREND
| OPENPAREND condition CLOSEPAREND
;

constraint:
TAKING? courseNameList // courses
| NUM credit_hours // creditHours
| NUM OF courseNameList // X of courses
| NUM UPPER DIVISION credit_hours // upper division hours
| TAKING courseNameList BEFORE courseName // prereqs

| LATER course_classes
| EARLIER course_classes

| MORE_ course_classes
| LESS course_classes
| MORE_ credit_hours
| LESS credit_hours

| NOT constraint // not
;


courseNameList: (STRING ',')* STRING;
courseName: STRING;
credit_hours: CREDITS | HOURS;
course_classes: COURSES | CLASSES;

// Statement Types
PRIORITY: 'priority';
REQUIRE: 'require';
PREFER: 'prefer';

IF: 'if';
THEN: 'then';
OTHERWISE: 'otherwise';
WHEN: 'when';
AND: 'and';
OR: 'or';

// Constraints

TAKING: 'taking';
BEFORE: 'before';

CREDITS: 'credits';
HOURS: 'hours';

UPPER: 'upper';
DIVISION: 'division';
OF: 'of';

LATER: 'later';
EARLIER: 'earlier';

LESS: 'less';
MORE_: 'more';


CLASSES: 'classes';
COURSES: 'courses';
NOT: 'not';

// Atoms
STRING: '"' .*? '"';
PERIOD: '.';
OPENPAREND: '(';
CLOSEPAREND: ')';
NUM: [0-9]+;
NAME: [a-zA-Z]('-'|'_'|[a-zA-Z0-9])*;

WS      : [ \t\n]+ -> skip ;  // tells ANTLR to ignore these
~~~~

Testing the Grammar
------------------
As we wrote out the grammar, we realized that there were several changes that needed to be made for parsing ease / usability.

1. we changed the `:` after a block name to `{ body }`.
2. We added `otherwise` as an option in addition to the `if` statements.
3. We added boolean logic to conditionals and forced parentheses around uses of `and` and `or` to make order of operations explicit.
4. We also fleshed out that the conditions for if statements might be and all the potential constraints for what might follow the `require` keyword.

These changes are reflected in the input listed in Project Selection.

We used the Definitive ANTLR 4 Reference book to implement strings, page 76.


Testing the Parser
------------------
<!--list correct and incorrect inputs-->
We made several good and bad input files.

Good Inputs: For the sake of space, I will just show the good output of `good-integrated.psl`, which
combines a lot of potential inputs.

![A screenshot showing the successful parsing of good-integrated.psl](images/good-integrated.png width="600px")

Bad Inputs:

### Bad And
~~~~
name {
    if taking "COS 120" taking "COS 121" then {
        require "COS 120".
    }
}
~~~~
![A screenshot showing the unsuccessful parsing of bad-and.psl](images/bad-and.png width="600px")

### Bad No Block
~~~~
require "COS 120".
~~~~
![A screenshot showing the unsuccessful parsing of bad-no-block.psl](images/bad-no-block.png width="600px")

### Bad Period
~~~~
name {
    require "COS 120"
}
~~~~
![A screenshot showing the unsuccessful parsing of bad-period.psl](images/bad-period.png width="600px")

### Bad Preference
~~~~
name {
    prefer "COS 120".
}
~~~~
![A screenshot showing the unsuccessful parsing of bad-preference.psl](images/bad-preference.png width="600px")

### Bad String
~~~~
name {
    require cos 120.
}
~~~~
![A screenshot showing the unsuccessful parsing of bad-string.psl](images/bad-string.png width="600px")

Splitting Up the Work
------------------
We did most of the main work of creating/fixing the grammar together.

Rob worked on a bit of the grammar on his own and made multiple correct and incorrect inputs.

Liz worked on the readme, generated the parser, and set up a java class to run inputs.

Translator
======================
Translator
------------------
~~~~
translator
~~~~

Testing the Translator
------------------

Splitting Up the Work
------------------

Documentation
======================


Splitting Up the Work
------------------

Reflection
======================
<!--
List any other comments below.
Feel free to provide any feedback on how much you learned from doing the assignment, and whether you enjoyed doing it.
-->


<!--   Feel free to modify the following to fit a theme of your choosing   -->
<link href="https://fonts.googleapis.com/css?family=Open+Sans&display=swap" rel="stylesheet"> <!-- a sans-serif font -->
<style>  /* A TAYLOR-INSPIRED THEME */
    body {font-family:'Open Sans',sans-serif;}
    .md a:link, .md a:visited {color:hsl(252,23.0%,44.3%); font-family:'Open Sans',sans-serif;}
    .md table.table th {background-color:hsl(252,23.0%,44.3%);}
    .md .noheader th {display:none;}
    .md .firstcol td:first-child {white-space:pre;color:white;vertical-align:top;font-weight:bold;border-color:black;background:hsl(252,23.0%,54.3%);}
    .md .firstcol tr:nth-child(even) td:first-child {background:hsl(252,23.0%,44.3%);}
</style>


<!-- ****************************** -->
<!--    Leave the content below     -->
<!-- ****************************** -->

<!-- The script and style below are added for clarity and to workaround a bug -->
<script>
    // this is a hack to workaround a bug in Markdeep+Mathjax, where
    // `$`` is automatically converted to `\(`` and `\)`` too soon.
    // the following code will replace the innerHTML of all elements
    // with class "dollar" with a dollar sign.
    setTimeout(function() {
        var dollars = document.getElementsByClassName('dollar');
        for(var i = 0; i < dollars.length; i++) {
            dollars[i].innerHTML = '&#' + '36;'; // split to prevent conversion to $
        }
    }, 1000);
</script>
<style>
    /* adding some styling to <code> tags (but not <pre><code> coding blocks!) */
    :not(pre) > code {
        background-color: rgba(0,0,0,0.05);
        outline: 1px solid rgba(0,0,0,0.15);
        margin-left: 0.25em;
        margin-right: 0.25em;
    }
    /* fixes table of contents of medium-length document from looking weird if admonitions are behind */
    .md div.mediumTOC { background: white; }
    .md div.admonition { position: initial !important; }
</style>

<!--   Leave the following Markdeep formatting code, as this will format your text above to look nice in a wed browser   -->

<script src="https://casual-effects.com/markdeep/latest/markdeep.min.js"></script><!-- Markdeep: --><style class="fallback">body{visibility:hidden;white-space:pre;font-family:monospace}</style><script src="markdeep.min.js"></script><script src="https://casual-effects.com/markdeep/latest/markdeep.min.js?"></script><script>window.alreadyProcessedMarkdeep||(document.body.style.visibility="visible")</script>
