**Project - Domain-Specific Language**

<!--

General
========

For each of your team's implementations, explain the following (where appropriate and applicable):

- details on calling conventions, input and output data formats, limitations, bugs, and special features.
- negative aspects of your program (limitations, known bugs)
- positive aspects (extensions, special features)
- describe your choice of modularization (abstractions), data structures, and algorithms
- explain anything you did that is likely to be different from what other students may have done
- justify any design decisions for which the rationale isn't immediately clear

Feel free to modify the structure of this `readme.html` file to fit the current assignment and to fit how you wish to present your findings.


-->


Authors
=============

<!-- Note: wrapping table in div.noheader will hide the table's header -->
<!-- Note: wrapping table in div.firstcol will style the first column different from other columns -->
<div class="noheader firstcol">
  1              | 2
------------------|-------------
names             | Rob Swanson & Liz Yeiter
computer + OS     | macbook
time to complete  | 2 hrs
partner           | see names
additional help   | see Reflection section
</div>



Project Selection
=================
Define the Domain
------------------
College course reccomendation based off of degree requirements and student preferences.
The end goal is to make a language that can specify user preferences for Envisage.

<!--(What is the purpose of the language?) -->
Define the Problem
------------------
How does the user express the requirements of their degree and their personal preferences to the planning engine?


<!-- Create example "solutions". What is the expected output for some examples of valid input? -->
Expected Solutions
------------------
The input would be a `.cps` file that specifies user preferences and degree requirements in a human readable format.
For example, the following file describes a few requirements and then specifies a few user preferences
~~~~
definitions:
	priority strongly 10.
	priority moderately 5.
	priority slightly 1.

computerScienceBSRequirements:
	require "COS 102".
	require "COS 103".
	require "COS 120".
	require "COS 121".

	require 1 of "COS 311", "COS 321".
	require 2 of "COS 381", "COS 421", "COS 436".

	require 128 hours.
	require 42 upper devision hours.

	require taking "COS 120" before "COS 121".

studentPreferences:
	prefer strongly "COS 121".
	prefer moderately later classes.

	if taking "COS 436" then {
		prefer slightly "COS 381".
		prefer slightly not taking "COS 421".
	}

	when taking "COS 381" {
		prefer moderately fewer credits.
	}
~~~~
[Example `input.cps`]

The output would be a python file which includes a python function for each requirement which takes in the context of a plan and returns some value corresponding to that requirement's satisfaction.
Other possible outputs could be a prolog fact file or a json document.
This output file would probably not be of much use to the user without other tools to create or pass in plans.

~~~~ Python
import helpers

STRONGLY = 10
MODERATLY = 5
SLIGHTLY = 1

def isValidPlan(plan):
    return (
        courseNameInPlan(plan, "COS 102") and
        courseNameInPlan(plan, "COS 103") and
        courseNameInPlan(plan, "COS 120") and
        courseNameInPlan(plan, "COS 121") and

        nCourseNamesInPlan(plan, 1, ["COS 311", "COS 321"]) and
        nCourseNamesInPlan(plan, 2, ["COS 381", "COS 421", "COS 436"]) and

        credits() >= 128 and
        creditsOver(plan, 300) >= 42 and

        leftBeforeRight(plan, "COS 120", "COS 121")
    )

def planScore(plan):
    totalScore = 0
    maxScore = 0

    totalScore += STRONGLY * courseNameInPlan(plan, "COS 121")
    (totalScore, maxScore) = applyPreference(totalScore, maxScore, percentage, STRONGLY, courseNameInPlan(plan, "COS 121"))
    (totalScore, maxScore) = applyPreference(totalScore, maxScore, sigmoid, MODERATLY, averageMeetingTime(plan))

    if courseNameInPlan("COS 436"):
        (totalScore, maxScore) = applyPreference(totalScore, maxScore, percentage, SLIGHTLY, courseNameInPlan(plan, "COS 381"))
        (totalScore, maxScore) = applyPreference(totalScore, maxScore, percentage, SLIGHTLY, not courseNameInPlan(plan, "COS 421"))

    if courseNameInPlan("COS 381"):
        semesterContext = contextFromSemester(plan, plan.courses["COS 381"].semseter)
        (totalScore, maxScore) = applyPreference(totalScore, maxScore, reverseSigmoid, MODERATLY, credits(semesterContext))

    return totalScore/maxScore

~~~~
[Example `output.py`]
The compiler could create a python file like this, which could take in a python object (which could be provided and decoded from JSON) and can specify whether the plan is valid, and also the level to which the user preferences are met.
This file includes the `helpers.py` file which **is not generated** and provides basic functionality that supports preference and requiremnt validation.

~~~~
def courseNameInPlan(context, courseName):
    return context.courses.contains(courseName)

def nCourseNamesInPlan(context, n, fromCourseNames):
    count = 0
    for courseName in fromCourseNames:
        if courseNameInPlan(context, courseName):
            count += 1
            if count >= n:
                return true
    return false

def leftBeforeRight(context, leftCourseName, rightCourseName):
    if courseNameInPlan(leftCourseName) and courseNameInPlan(rightCourseName):
        return context.courses[leftCourseName].semseter < context.courses[rightCourseName].semseter

EARLIEST_MEETING_TIME = 800
LATEST_MEETING_TIME = 1500

def averageMeetingTime(context):
    timeSum = 0
    for meeting in context.meetings:
        timeSum += (meeting.time - EARLIEST_MEETING_TIME) / (LATEST_MEETING_TIME - EARLIEST_MEETING_TIME)
    return timeSum / len(context.meetings)

def credits(context):
    creditSum = 0
    for meeting in context.meetings:
        creditSum += meeting.credits
    return creditSum

def creditsOver(context, minCourseNumber):
    creditSum = 0
    for meeting in context.meetings:
        if meeting.courseNumber >= minCourseNumber:
            creditSum += meeting.credits
    return creditSum

def applyPreference(totalScore, maxScore, scaler, weight, score):
    return (totalScore+weight*scaler(preferenceSatisfaction), maxScore+weight)

def percentage(score):
    return min(max(score, 1), 0) * weight

def sigmoid(score):
    return weight/(1+10**(-score))
def reverseSigmoid(score):
    return weight/(1+10**(score))

def contextFromSemester(contextIn, semester):
    contextOut = { courses: [], meetings: [] }
    for meeting in contextIn.meeting:
        if meeting.semester == semester:
            contextOut.courses.append(meeting.course)
            contextOut.meetings.append(meeting)
~~~~
[helpers.py]
<!-- Define functionality. How is the output determined for a given input? -->
Define Functionality
------------------
A person making use of this system would start by creating a `.cps` input file that follows the language specification to define the requirements of their degrees (possibly by importing from other files).
They would then run the compiler which would produce a python file with two functions:
1. `isValidPlan(plan)` which returns a boolean
2. `planScore(plan)` which returns a double between 0 and 1, with 1 being the highest possible score, which can only be achived when all applied preferences are fully met (which is not possible for preferences which use a sigmoid function).
The user could populate a python object however they wish, but would likely do so by specifying a canidate plan in json, and then decoding it.
They could then pass this object to either function to evaluate it.

<!-- Talk with the professor, and get approval. -->
Approval
------------------


Splitting Up the Work
------------------

Grammar
================
Grammar
------------------
~~~~
grammar
~~~~

Testing the Grammar
------------------

Splitting Up the Work
------------------

Parser
======================
Parser
------------------
~~~~
parser
~~~~

Testing the Parser
------------------

Splitting Up the Work
------------------

Translator
======================
Translator
------------------
~~~~
translator
~~~~

Testing the Translator
------------------

Splitting Up the Work
------------------

Documentation
======================


Splitting Up the Work
------------------

Reflection
======================
<!--
List any other comments below.
Feel free to provide any feedback on how much you learned from doing the assignment, and whether you enjoyed doing it.
-->






<!-- THE FOLLOWING IS HERE ONLY FOR REFERENCE  -->
<!-- DELETE THE FOLLOWING SECTION BEFORE SUBMITTING TO CANVAS -->
<!-- VVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVV -->

A Few Markdeep Examples
========================

I have left some examples below to demonstrate how you can format your write-up using Markdeep.
For more details, see [http://casual-effects.com/markdeep/features.md.html](http://casual-effects.com/markdeep/features.md.html).
Remove this section from your final submission :)


Below is a "Hello, World!" Python program.
You can include code (`x = 2`) in your sentences, too!

~~~~
#!/usr/bin/python

print("Hello, World!")
~~~~

Below is a screenshot showing me running the program above.

![A screenshot showing Python running a "Hello, World!" program.](screenshot.png width="600px")

Note: included images need to be included along with the `readme.html` file.


You can even include math ($x = 2$) in your readme.
For larger equations, use double dollar signs!

$$ f(x) = \sum_{x=0}^{100} \frac{x^2 + 1}{2x + 1} $$


<!-- ΛΛΛΛΛΛΛΛΛΛΛΛΛΛΛΛΛΛΛΛΛΛΛΛΛΛΛΛΛΛΛΛΛΛΛΛΛΛΛΛΛΛΛΛΛΛΛΛΛΛΛΛΛΛΛΛ -->





<!--   Feel free to modify the following to fit a theme of your choosing   -->
<link href="https://fonts.googleapis.com/css?family=Open+Sans&display=swap" rel="stylesheet"> <!-- a sans-serif font -->
<style>  /* A TAYLOR-INSPIRED THEME */
    body {font-family:'Open Sans',sans-serif;}
    .md a:link, .md a:visited {color:hsl(252,23.0%,44.3%); font-family:'Open Sans',sans-serif;}
    .md table.table th {background-color:hsl(252,23.0%,44.3%);}
    .md .noheader th {display:none;}
    .md .firstcol td:first-child {white-space:pre;color:white;vertical-align:top;font-weight:bold;border-color:black;background:hsl(252,23.0%,54.3%);}
    .md .firstcol tr:nth-child(even) td:first-child {background:hsl(252,23.0%,44.3%);}
</style>


<!-- ****************************** -->
<!--    Leave the content below     -->
<!-- ****************************** -->

<!-- The script and style below are added for clarity and to workaround a bug -->
<script>
    // this is a hack to workaround a bug in Markdeep+Mathjax, where
    // `$`` is automatically converted to `\(`` and `\)`` too soon.
    // the following code will replace the innerHTML of all elements
    // with class "dollar" with a dollar sign.
    setTimeout(function() {
        var dollars = document.getElementsByClassName('dollar');
        for(var i = 0; i < dollars.length; i++) {
            dollars[i].innerHTML = '&#' + '36;'; // split to prevent conversion to $
        }
    }, 1000);
</script>
<style>
    /* adding some styling to <code> tags (but not <pre><code> coding blocks!) */
    :not(pre) > code {
        background-color: rgba(0,0,0,0.05);
        outline: 1px solid rgba(0,0,0,0.15);
        margin-left: 0.25em;
        margin-right: 0.25em;
    }
    /* fixes table of contents of medium-length document from looking weird if admonitions are behind */
    .md div.mediumTOC { background: white; }
    .md div.admonition { position: initial !important; }
</style>

<!--   Leave the following Markdeep formatting code, as this will format your text above to look nice in a wed browser   -->

<script src="https://casual-effects.com/markdeep/latest/markdeep.min.js"></script><!-- Markdeep: --><style class="fallback">body{visibility:hidden;white-space:pre;font-family:monospace}</style><script src="markdeep.min.js"></script><script src="https://casual-effects.com/markdeep/latest/markdeep.min.js?"></script><script>window.alreadyProcessedMarkdeep||(document.body.style.visibility="visible")</script>
